### 锁池

```java
假设一个线程此时拥有了对象锁,另外一个线程调用这个被锁对象的某个synchronized方法或者synchronized块,则这个线程就会被放入到这个被锁对象的锁池中
```

### 等待池

```java
假设一个线程此时拥有了对象锁,如果此时调用这个被锁对象的wait方法
则此线程就会进入到这个被锁对象的等待池中,同时此线程释放掉对象锁
```

---

### 可见性

定义

```java
一个线程修改了变量的值
其他线程能立刻看得到修改的值
```

多线程问题

```java
每个线程都有自己的缓存空间,每个线程对变量的操作都是在自己的缓存空间中进行的,操作完后再将修改后的值返回给主存中

假设A线程将共享变量修改后,还没有来的及将缓存中的变量返回给主存中
另外B线程这时候也要对共享变量进行修改,那么B线程此时拿到的值就是主存中还未被修改的值
这就是可见性问题
```

volatile

```java
当共享变量被volatile修饰时,会保证修改的值立即更新到主存中
而且当有其他线程需要读取这个共享变量时,它会去主存中读取最新值
```

volatile不能保证原子性

```java
共享变量i被volatile修饰
这时两个线程对其进行i++操作
i++其实是两步操作,读取和++
线程A将i的值读取到自己的缓存空间,但是还没来得及进行++操作,就阻塞了
线程B也将i的值读取到自己的缓存空间,然后对其进行++,由于使用volatile修饰,会立即将++的结果立即写入到主存中
线程A阻塞结束后,并不会重新读取i,而是接着执行++
这就是为什么volatile不能保证原子性
```

---

### CAS

```java
一个线程间共享的变量,首先在主存中会保留一份,然后每个线程的工作内存也会保留一份副本
预期值就是线程保留的副本
线程从主存中获取变量的值后,主存中的变量此时可能已经被其他线程修改,但是该线程工作内存中变量却还是原来的值,这就是所谓的预期值了
当要用CAS刷新该值的时候,如果发现线程工作内存和主存中不一致了,就会失败,如果一致,就可以更新成功.
```

---

