#### 1.RebalanceService#run

```java
public void run() {
  while (!this.isStopped()) {
    //消费者每20秒执行一次负载均衡
    this.waitForRunning(20000);
    this.mqClientFactory.doRebalance();
  }
}
```

#### 2.MQClientInstance#doRebalance

```java
public void doRebalance() {
  //<消费者组, DefaultMQPushConsumerImpl>
	for (Map.Entry<String, MQConsumerInner> entry : this.consumerTable.entrySet()) {
		MQConsumerInner impl = entry.getValue();
    impl.doRebalance();
  }
}
```

#### 3.DefaultMQPushConsumerImpl#doRebalance

```java
public void doRebalance() {
	this.rebalanceImpl.doRebalance(this.isConsumeOrderly());
}
```

#### 4.RebalancePushImpl#doRebalance

```java
public void doRebalance(final boolean isOrder) {
  //<Topic, SubscriptionData>
	Map<String, SubscriptionData> subTable = this.getSubscriptionInner();
  for (final Map.Entry<String, SubscriptionData> entry : subTable.entrySet()) {
    final String topic = entry.getKey();
    this.rebalanceByTopic(topic, isOrder);
  }
}
↓
↓
private void rebalanceByTopic(final String topic, final boolean isOrder) {
  case CLUSTERING: {
    //MessageQueue中包含了Topic,BrokerName,QueueId
    Set<MessageQueue> mqSet = this.topicSubscribeInfoTable.get(topic);
    //返回所有消费者ID(IP@PID)
    List<String> cidAll = this.mQClientFactory.findConsumerIdList(topic, consumerGroup); //5

    List<MessageQueue> mqAll = new ArrayList<>();
    mqAll.addAll(mqSet);
    
    //为了分配一致,这里要进行排序
    Collections.sort(mqAll);
    Collections.sort(cidAll);

    //计算出当前这个消费者ID需要消费哪几个消息队列
    /**
       * 默认算法如下:
       * 1个消费者,[1->1,2,3,4]
       * 2个消费者,[1->1,2][2->3,4]
       * 3个消费者,[1->1,2][2->3][3->4]
       * 4个消费者,[1->1][2->2][3->3][4->4]
       * 5个消费者,[1->1][2->2][3->3][4->4][5->没有队列分配给它]
       */
    List<MessageQueue> allocateResult = this.allocateMessageQueueStrategy.allocate(
      this.consumerGroup,                   //消费者组
      this.mQClientFactory.getClientId(),   //IP@PID
      mqAll,
      cidAll);

    Set<MessageQueue> allocateResultSet = new HashSet<>();
    allocateResultSet.addAll(allocateResult);

    /**
     * 1.如果消费者原来有这个队列,负载均衡之后没有了这个队列
     *		需要将这个队列的消费进度持久化,停止消费这个队列
     * 2.如果消费者原来没有这个队列,负载均衡之后有了这个队列
     *		创建PullRequest请求,提交给PullMessageService去拉取消息进行消费
     */
    boolean changed = this.updateProcessQueueTableInRebalance(topic, allocateResultSet, isOrder);
    if (changed) {
      //如果当前消费者消费的队列发生了改变,这里会发送心跳给所有Broker
			this.messageQueueChanged(topic, mqSet, allocateResultSet); 
    }
  }
}
↓
↓
private boolean updateProcessQueueTableInRebalance(final String topic,
                                                   final Set<MessageQueue> mqSet,
                                                   final boolean isOrder) {
	boolean changed = false;
  //当前消费者正在消费的队列
  Iterator<Entry<MessageQueue, ProcessQueue>> it = this.processQueueTable.entrySet().iterator();
  while(it.hasNext()){
    Entry<MessageQueue, ProcessQueue> next = it.next();
    MessageQueue mq = next.getKey();
    ProcessQueue pq = next.getValue();
  
    //新分配的消费队列中不包含这个老队列
    if (!mqSet.contains(mq)) {
      //标记ProcessQueue#drop为true
      pq.setDropped(true);
      /**
       * 将这个老队列的消费进度发送到Broker
       * 当前消费者的OffsetStore中移除这个老队列
       */
			if (this.removeUnnecessaryMessageQueue(mq, pq)) {
	      it.remove();
				changed = true;
      }
    }
  }
  
  List<PullRequest> pullRequestList = new ArrayList<>();
  for (MessageQueue mq : mqSet) {
    //消费者不包含这个新的队列
    if (!this.processQueueTable.containsKey(mq)) {
			ProcessQueue pq = new ProcessQueue();
      //从Broker中获取这个新的队列的消费位置
      long nextOffset = this.computePullFromWhere(mq); //6
			if (nextOffset >= 0) {
      	this.processQueueTable.putIfAbsent(mq, pq);
        
        PullRequest pullRequest = new PullRequest();
        pullRequest.setConsumerGroup(consumerGroup);
        pullRequest.setNextOffset(nextOffset);
        pullRequest.setMessageQueue(mq);
        pullRequest.setProcessQueue(pq);
        pullRequestList.add(pullRequest);
        changed = true;
      }
    }
  }
  
  //将上面的PullRequest请求放入阻塞队列
	this.dispatchPullRequest(pullRequestList);

  return changed;
}
```

#### 5.MQClientInstance#findConsumerIdList

```java
public List<String> findConsumerIdList(final String topic, final String group) {
  //随机返回Topic下的一个Broker地址(这也表示每个Broker都能查到这个消费者组下所有的消费者)
  String brokerAddr = this.findBrokerAddrByTopic(topic);
  //从这个Broker地址中获取消费者组下所有消费者ID(IP@PID)
  return this.mQClientAPIImpl.getConsumerIdListByGroup(brokerAddr, group, 3000);
}
```

#### 6.RebalancePushImpl#computePullFromWhere

```java
public long computePullFromWhere(MessageQueue mq) {
	long result = -1;
  final OffsetStore offsetStore = this.defaultMQPushConsumerImpl.getOffsetStore();
  case CONSUME_FROM_LAST_OFFSET: {
		long lastOffset = offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE); //7
    if (lastOffset >= 0) {
      result = lastOffset;
    }
    break;
  }
  return result;
}
```

#### 7.RemoteBrokerOffsetStore#readOffset

```java
public long readOffset(final MessageQueue mq, final ReadOffsetType type) {
	switch (type) {
  	case READ_FROM_STORE: {
      //从Broker中获取队列的消费位置
      long brokerOffset = this.fetchConsumeOffsetFromBroker(mq);
      //更新内存中的消费位置
      this.updateOffset(mq, brokerOffset, false);
      return brokerOffset;
    }
  }
}
↓
↓
private long fetchConsumeOffsetFromBroker(MessageQueue mq) {
  //获取Broker地址
  FindBrokerResult findBrokerResult = this.mQClientFactory.findBrokerAddressInAdmin(mq.getBrokerName());
  //构建请求头
  QueryConsumerOffsetRequestHeader requestHeader = new QueryConsumerOffsetRequestHeader();
  requestHeader.setTopic(mq.getTopic());
  requestHeader.setConsumerGroup(this.groupName);
  requestHeader.setQueueId(mq.getQueueId());
	//返回消费位置
  return this.mQClientFactory.getMQClientAPIImpl().queryConsumerOffset(
    findBrokerResult.getBrokerAddr(),
    requestHeader,
    1000 * 5);
}
↓
↓
public void updateOffset(MessageQueue mq, long offset, boolean increaseOnly) {
	AtomicLong offsetOld = this.offsetTable.get(mq);
  if (null == offsetOld) {
    offsetOld = this.offsetTable.putIfAbsent(mq, new AtomicLong(offset));
  }
  if (null != offsetOld) {
    if (increaseOnly) {
      MixAll.compareAndIncreaseOnly(offsetOld, offset);
    } else {
      offsetOld.set(offset);
    }
  }
}
```

