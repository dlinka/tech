#### 缓存雪崩

```java
缓存使用了相同的过期时间,这样就会导致同一时间缓存大量过期,而导致大量请求去数据库中查询,给数据库带来巨大压力
  
解决方案一
  缓存的过期时间加上一个随机时间
```



#### 数据库和缓存一致性问题

##### 1.先更新缓存，再更新数据库

异常情况

```java
//数据都没有持久化，就给用户了！
先更新缓存成功->再更新数据库失败
```

##### 2.先更新数据库，再更新缓存

异常情况

```java
//数据持久化了，但是用户还是用的老的数据！
先更新数据库成功->再更新缓存失败
```

并发情况

```java
线程A更新数据库
线程B更新数据库
线程B更新缓存
线程A更新缓存
```

缓存利用率

```
无脑更新缓存，但是缓存又不一定会被马上读取
```

##### 3.先删除缓存，再更新数据库

并发情况

```java
线程A删除缓存
线程B请求缓存不存在，请求数据库得到旧值，写入缓存
线程A将新值写入数据库

//如果是MySQL读写分离的架构
线程A删除缓存，然后将新值写入数据库
线程B请求缓存不存在，请求从库，这是还没有完成主从同步，得到旧值，写入缓存
数据库完成主从同步，从库变为新值

//解决方案
延迟删除，在线程A写入数据库后，隔一段时间删除缓存，将线程B在写入数据库这段时间构建的缓存删掉
//延迟删除失败了怎么办？
```

##### 4.先更新数据库，再删除缓存

并发情况

```java
缓存失效
线程A读取旧值
线程B将新值写入数据库，删除缓存
线程A写入缓存

//其实这种情况发生的概率很低，要满足如下三个条件才可能发生
1.要保证缓存正好失效
2.读写请求并发执行
3.更新数据库 + 删除缓存的时间 < 读取数据+写缓存的时间
```

异常情况

```
先更新数据库成功
再删除缓存失败

解决方案
	重试删除
	但是立即重试删除很大概率还是会失败，最好是异步重试，把删除请求发到消息队列
```



